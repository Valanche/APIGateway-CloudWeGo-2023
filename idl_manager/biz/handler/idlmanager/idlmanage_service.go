// Code generated by hertz generator.

package idlmanager

import (
	"context"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	idlmanager "api/idl_manager/biz/model/idlmanager"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

var idlPath string
var gatewayPath string
var relativePath string

// SetIdlPath .
// @router manage/Path [POST]
func SetIdlPath(ctx context.Context, c *app.RequestContext) {
	
	var err error
	var req idlmanager.SetIdlPathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(idlmanager.ManageServiceResp)

	if req.IdlPath[0] != '/' && req.GateWayPath[0] != '/' {
		resp.RespBody = "path must be absolute path"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	temp := GetRelativePath(req.GateWayPath, req.IdlPath)
	if temp == "" {
		resp.RespBody = "idlPath is not under gateWayPath"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	idlPath = req.IdlPath
	gatewayPath = req.GateWayPath
	relativePath = temp

	if !strings.HasSuffix(idlPath, "/") {
		idlPath += "/"
	}

	resp.RespBody = "idl path is " + idlPath + " now"

	c.JSON(consts.StatusOK, resp)
}

// AddService .
// @router /manage/Add [POST]
func AddService(ctx context.Context, c *app.RequestContext) {
	var err error
	var req idlmanager.IdlService
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(idlmanager.ManageServiceResp)

	svcPath := filepath.Join(idlPath, "svcPath")

	// Check if svcPath file exists
	if _, err := os.Stat(svcPath); os.IsNotExist(err) {
		// Create svcPath file if it doesn't exist
		err := ioutil.WriteFile(svcPath, []byte{}, 0666)
		if err != nil {
			resp.RespBody = "failed to create svcPath file: " + err.Error()
			c.JSON(consts.StatusBadRequest, resp)
			return
		}
	}

	// Read the content of svcPath file
	content, err := ioutil.ReadFile(svcPath)
	if err != nil {
		resp.RespBody = "failed to read svcPath file: " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Check if req.Name already exists in svcPath
	if strings.Contains(string(content), req.Name) {
		resp.RespBody = "svcName '" + req.Name + "' already exists in svcPath"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Append req.Name and req.FileName to svcPath
	newLine := req.Name + ", " + relativePath + req.FileName + "\n"
	err = ioutil.WriteFile(svcPath, append(content, []byte(newLine)...), 0666)
	if err != nil {
		resp.RespBody = "failed to write to svcPath file: " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Create req.FileName file in idlPath with req.FileContent
	filePath := filepath.Join(idlPath, req.FileName)
	err = ioutil.WriteFile(filePath, []byte(req.FileContent), 0666)
	if err != nil {
		resp.RespBody = "failed to create req.FileName file: " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	resp.RespBody = "add service success"
	c.JSON(consts.StatusOK, resp)
}

// ChangeService .
// @router /manage/Change [POST]
func ChangeService(ctx context.Context, c *app.RequestContext) {
	var err error
	var req idlmanager.ChangeServiceReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(idlmanager.ManageServiceResp)

	svcPath := filepath.Join(idlPath, "svcPath")
	if _, err := os.Stat(svcPath); os.IsNotExist(err) {
		resp.RespBody = "svcPath file not found in idlPath"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Read the content of svcPath file
	content, err := ioutil.ReadFile(svcPath)
	if err != nil {
		resp.RespBody = "failed to read svcPath file: " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}
	lines := strings.Split(string(content), "\n")

	// Find the line that matches req.Name
	path := ""
	for _, line := range lines {
		strs := strings.Split(line, ", ")
		if len(strs) == 2 && strs[0] == req.Name {
			path = strs[1]
			break
		}
	}

	if path == "" {
		resp.RespBody = "svcName '" + req.Name + "' not found in svcPath file"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Update the file specified by gatewayPath+strs[1] with req.FileContent
	gatewayFilePath := filepath.Join(gatewayPath, path)
	err = ioutil.WriteFile(gatewayFilePath, []byte(req.FileContent), 0644)
	if err != nil {
		resp.RespBody = "failed to update gateway file: " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	resp.RespBody = "write success"
	c.JSON(consts.StatusOK, resp)
}

// DeleteService .
// @router /manage/Delete [POST]
func DeleteService(ctx context.Context, c *app.RequestContext) {
	var err error
	var req idlmanager.DeleteServiceReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(idlmanager.ManageServiceResp)

	// 打开"svcPath.txt"文件
	filePath := filepath.Join(idlPath, "svcPath")
	fileContent, err := ioutil.ReadFile(filePath)
	if err != nil {
		resp.RespBody = "Error reading svcPath : " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	lines := strings.Split(string(fileContent), "\n")
	var updatedLines []string

	// 遍历每一行，查找匹配并删除文件
	for _, line := range lines {
		strs := strings.Split(line, ", ")
		if len(strs) >= 2 && strs[0] == req.Name {
			fileToDelete := filepath.Join(gatewayPath, strs[1])
			err := os.Remove(fileToDelete)
			if err != nil {
				resp.RespBody = "Error deleting file" + fileToDelete + err.Error()
				c.JSON(consts.StatusBadRequest, resp)
				return
			}
		} else {
			updatedLines = append(updatedLines, line)
		}
	}

	// 更新"svcPath.txt"文件
	updatedContent := strings.Join(updatedLines, "\n")
	err = ioutil.WriteFile(filePath, []byte(updatedContent), 0644)
	if err != nil {
		resp.RespBody = "Error deleting the line in svcPath file" + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	resp.RespBody = "delete success"
	c.JSON(consts.StatusOK, resp)
}

// GetService .
// @router /manage/Get [GET]
func GetService(ctx context.Context, c *app.RequestContext) {
	var err error
	var req idlmanager.GetServiceReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(idlmanager.ManageServiceResp)

	svcPath := filepath.Join(idlPath, "svcPath")
	if _, err := os.Stat(svcPath); os.IsNotExist(err) {
		resp.RespBody = "svcPath file not found in idlPath"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Read the content of svcPath file
	content, err := ioutil.ReadFile(svcPath)
	if err != nil {
		resp.RespBody = "failed to read svcPath file: " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}
	lines := strings.Split(string(content), "\n")

	// Find the line that matches req.Name
	path := ""
	for _, line := range lines {
		strs := strings.Split(line, ", ")
		if len(strs) == 2 && strs[0] == req.Name {
			path = strs[1]
			break
		}
	}

	if path == "" {
		resp.RespBody = "svcName '" + req.Name + "' not found in svcPath file"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Update the file specified by gatewayPath+strs[1] with req.FileContent
	gatewayFilePath := filepath.Join(gatewayPath, path)
	content, err = ioutil.ReadFile(gatewayFilePath)
	if err != nil {
		resp.RespBody = "failed to read thrift file: " + path + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	resp.RespBody = req.Name
	var strs [2]string
	strs[0] = strings.TrimPrefix(path,relativePath)
	strs[1] = string(content)
	resp.Items = strs[:]

	c.JSON(consts.StatusOK, resp)
}

// ListServices .
// @router /manage/List [GET]
func ListServices(ctx context.Context, c *app.RequestContext) {
	// var err error

	resp := new(idlmanager.ManageServiceResp)

	svcPath := filepath.Join(idlPath, "svcPath")
	if _, err := os.Stat(svcPath); os.IsNotExist(err) {
		resp.RespBody = "svcPath file not found in idlPath"
		c.JSON(consts.StatusBadRequest, resp)
		return
	}

	// Read the content of svcPath file
	content, err := ioutil.ReadFile(svcPath)
	if err != nil {
		resp.RespBody = "failed to read svcPath file: " + err.Error()
		c.JSON(consts.StatusBadRequest, resp)
		return
	}
	lines := strings.Split(string(content), "\n")
	var respArr []string

	for _, line := range lines {
		strs := strings.Split(line, ", ")
		if len(strs) == 2 {
			respArr = append(respArr, strs[0])
		}
	}

	resp.RespBody = "success"
	resp.Items = respArr


	c.JSON(consts.StatusOK, resp)
}

func Init() {
	idlPath = "/home/hanbo/Documents/cloudWeGo/project2/APIGateway-CloudWeGo-2023/cmd/idl/test"
	gatewayPath = "/home/hanbo/Documents/cloudWeGo/project2/APIGateway-CloudWeGo-2023/cmd"
	relativePath = GetRelativePath(gatewayPath, idlPath)
}

func GetRelativePath(basePath, seekingPath string) string {
	basePath = filepath.Clean(basePath)
	seekingPath = filepath.Clean(seekingPath)

	// Check if seekingPath is under basePath
	if !strings.HasPrefix(seekingPath, basePath) {
		return "" // seekingPath is not under basePath
	}

	// Calculate relative path from basePath to seekingPath
	relativePath, err := filepath.Rel(basePath, seekingPath)
	if err != nil {
		return "" // Error occurred while calculating relative path
	}

	return relativePath + "/"
}
