## 测试优化文档

主要通过pprof测试时间、空间占用情况

### 一、数据库查询优化
### 1. 测试查询

**运行测试：**  

在第一个终端运行压测
```bash
    echo '{"id":1}' >> post_data.txt
    ab -n 100000 -c 10 -p post_data.txt -T application/json -H "Content-Type: application/json" http://localhost:8888/api/kitex.demo/Query
```
在第二个终端运行pprof ui：
```bash 
    go tool pprof -http=:8081 http://localhost:8083
```
等30秒，pprof的网页就可以自动生成
![Alt text](dbimage.png)

ab的输出
```
Percentage of the requests served within a certain time (ms)
  50%     61
  66%     63
  75%     65
  80%     66
  90%     71
  95%    242
  98%    258
  99%    267
 100%   1341 (longest request)
 ```

可以看到数据库查询占用了相当长的时间，因此考虑加缓存

**加了缓存后的效果**
![!\[Alt text\](images/image1.png)](dbimage1.png)

ab的输出
```
Percentage of the requests served within a certain time (ms)
  50%      2
  66%      2
  75%      3
  80%      3
  90%      4
  95%      5
  98%      7
  99%      9
 100%    125 (longest request)
 ```


### 二、json处理优化
观察网关层的火焰图可以发现，除了generic call之外，json.Unmarshal也占用了较长时间。考虑使用性能较高的开源gjson库。
![Alt text](image.png)


```golang

  //gateway.go
  m, _ := gjson.Parse(resp.(string)).Value().(map[string]interface{})

```

可以看到新的火焰图中json.Unmarshal几乎已经没有时间占用了
![Alt text](image-1.png)

### 三、连接池处理优化
观察正常运行一次压力测试的pprof的top
![Alt text](<屏幕截图 2023-07-26 214206.png>)
占用时间最长的是genericcall中的syscall6，其次是futex。代码在实现时一直在复用同一个genericclient，因此猜测可能是在并发的情况下一个client有点不够用。考虑引入客户端连接池，保存10个client，轮流使用。

```golang
  //provider.go
var gCliCount = make(map[string]int)
var gCliPool = make(map[string][10]*genericclient.Client)
var mutex sync.Mutex
```

使用连接池之后的top，耗时降低了一些。
![Alt text](<屏幕截图 2023-07-26 215119.png>)
